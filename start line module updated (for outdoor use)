#include <Arduino.h>
#include <WiFi.h>
#include <esp_now.h>
// Define pin assignments
#define READY_LED 32
#define LASER_ALIGNED_LED 33
#define CONNECTION_FAIL_LED 25
#define CONNECTION_SUCCESS_LED 26
#define BUZZER 22
#define LASER_SENSOR 23
// CORRECTED: Using the MAC address from the finish line module code
uint8_t finishLineMacAddress[] = {0xE8, 0x6B, 0xEA, 0xDF, 0xA2, 0x68};
// Timing variables
volatile bool laserAligned = false;
bool connectionActive = false;
bool readyToTime = false;
bool timingCycleActive = false;
// Frequency measurement variables
volatile unsigned long pulseCount = 0;
volatile unsigned long lastPulseTime = 0;
unsigned long lastFreqCheck = 0;
const unsigned long FREQ_CHECK_INTERVAL = 250; // Check frequency every 250ms for stability
const float TARGET_FREQ = 2000.0;
const float FREQ_TOLERANCE = 1000.0;
float currentFrequency = 0.0;
// Laser state tracking for stability
bool laserDetectedRaw = false;
bool lastLaserState = false;
unsigned long lastLaserStateChange = 0;
const unsigned long LASER_STABILITY_TIME = 100; // Require 100ms of stable state
int alignmentCounter = 0;
const int ALIGNMENT_THRESHOLD = 3; // Require 3 consecutive good readings
// Communication variables
typedef struct struct_message {
uint8_t msgType;  // 0 for heartbeat, 1 for start timing
bool localAligned;
bool cooldown;
} struct_message;
struct_message outgoingMsg;
struct_message incomingMsg;
// Last time we received a heartbeat from the finish line
unsigned long lastHeartbeatReceived = 0;
const unsigned long HEARTBEAT_TIMEOUT = 3000;  // 3 seconds timeout
const unsigned long HEARTBEAT_INTERVAL = 1000; // Send heartbeat every 1 second
unsigned long lastHeartbeatSent = 0;
bool remoteAligned = false;
bool remoteCooldown = false;
// Function prototypes
void sendHeartbeat();
void sendStartSignal();
void initESPNow();
void updateReadyToTime();
// Callback when data is sent
void OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {
if (status != ESP_NOW_SEND_SUCCESS) {
digitalWrite(CONNECTION_FAIL_LED, HIGH);
digitalWrite(CONNECTION_SUCCESS_LED, LOW);
connectionActive = false;
} else {
digitalWrite(CONNECTION_FAIL_LED, LOW);
digitalWrite(CONNECTION_SUCCESS_LED, HIGH);
}
}
// Callback when data is received - using the newer ESP-NOW API format
void OnDataRecv(const esp_now_recv_info_t *info, const uint8_t *incomingData, int len) {
memcpy(&incomingMsg, incomingData, sizeof(incomingMsg));
if (incomingMsg.msgType == 0) {  // Heartbeat message
lastHeartbeatReceived = millis();
connectionActive = true;
remoteAligned = incomingMsg.localAligned;
remoteCooldown = incomingMsg.cooldown;
Copy// Update ready to time status
updateReadyToTime();
}
}
// Interrupt service routine for pulse counting (frequency measurement)
void IRAM_ATTR pulseCountISR() {
unsigned long currentTime = micros();
// Simple debounce - ignore pulses that come too fast (noise)
if (currentTime - lastPulseTime > 100) { // 100 microseconds debounce
pulseCount++;
lastPulseTime = currentTime;
}
}
// Check for laser break (called from main loop)
void checkLaserBreak() {
static bool lastReadyState = false;
static unsigned long beamBrokenTime = 0;
static bool beamWasBroken = false;
bool currentLaserState = digitalRead(LASER_SENSOR);
// Detect transition from ready to not ready (beam break)
if (lastReadyState && readyToTime && !currentLaserState && !timingCycleActive) {
if (!beamWasBroken) {
beamWasBroken = true;
beamBrokenTime = millis();
} else if (millis() - beamBrokenTime > 10) { // 10ms debounce
timingCycleActive = true;
sendStartSignal();
tone(BUZZER, 1000, 100);  // Beep to indicate timing start
beamWasBroken = false;
}
} else {
beamWasBroken = false;
}
lastReadyState = readyToTime;
}
// Update the laser aligned status with frequency check
void updateLaserStatus() {
unsigned long currentMillis = millis();
// Read current laser state
bool currentState = digitalRead(LASER_SENSOR) == HIGH;
// Track state changes for stability
if (currentState != lastLaserState) {
lastLaserStateChange = currentMillis;
lastLaserState = currentState;
}
// Only update detected state if it's been stable
if (currentMillis - lastLaserStateChange > LASER_STABILITY_TIME) {
laserDetectedRaw = currentState;
}
// Check if it's time to calculate frequency
if (currentMillis - lastFreqCheck >= FREQ_CHECK_INTERVAL) {
// Disable interrupts briefly to read pulse count
noInterrupts();
unsigned long count = pulseCount;
pulseCount = 0;
interrupts();
Copy// Calculate frequency
currentFrequency = (float)count * (1000.0 / FREQ_CHECK_INTERVAL);

// Check if frequency is in valid range AND laser is detected
bool frequencyValid = (currentFrequency >= (TARGET_FREQ - FREQ_TOLERANCE) && 
                      currentFrequency <= (TARGET_FREQ + FREQ_TOLERANCE));

// Update alignment counter for stability
if (laserDetectedRaw && frequencyValid) {
  if (alignmentCounter < ALIGNMENT_THRESHOLD) {
    alignmentCounter++;
  }
} else {
  if (alignmentCounter > 0) {
    alignmentCounter--;
  }
}

// Only change aligned state after threshold is met
laserAligned = (alignmentCounter >= ALIGNMENT_THRESHOLD);

lastFreqCheck = currentMillis;
}
// Update LED
digitalWrite(LASER_ALIGNED_LED, laserAligned ? HIGH : LOW);
}
// Update the ready to time status
void updateReadyToTime() {
readyToTime = laserAligned && remoteAligned && connectionActive && !remoteCooldown && !timingCycleActive;
digitalWrite(READY_LED, readyToTime ? HIGH : LOW);
}
// Initialize ESP-NOW
void initESPNow() {
WiFi.mode(WIFI_STA);
if (esp_now_init() != ESP_OK) {
Serial.println("Error initializing ESP-NOW");
return;
}
esp_now_register_send_cb(OnDataSent);
esp_now_peer_info_t peerInfo = {};
memcpy(peerInfo.peer_addr, finishLineMacAddress, 6);
peerInfo.channel = 0;
peerInfo.encrypt = false;
if (esp_now_add_peer(&peerInfo) != ESP_OK) {
Serial.println("Failed to add peer");
return;
}
esp_now_register_recv_cb(OnDataRecv);
}
// Send heartbeat message to finish line module
void sendHeartbeat() {
outgoingMsg.msgType = 0;
outgoingMsg.localAligned = laserAligned;
outgoingMsg.cooldown = false;
esp_err_t result = esp_now_send(finishLineMacAddress, (uint8_t *)&outgoingMsg, sizeof(outgoingMsg));
if (result != ESP_OK) {
connectionActive = false;
digitalWrite(CONNECTION_FAIL_LED, HIGH);
digitalWrite(CONNECTION_SUCCESS_LED, LOW);
}
}
// Send start timing signal
void sendStartSignal() {
outgoingMsg.msgType = 1;  // Start timing message
outgoingMsg.localAligned = laserAligned;
outgoingMsg.cooldown = false;
esp_err_t result = esp_now_send(finishLineMacAddress, (uint8_t *)&outgoingMsg, sizeof(outgoingMsg));
if (result != ESP_OK) {
connectionActive = false;
digitalWrite(CONNECTION_FAIL_LED, HIGH);
digitalWrite(CONNECTION_SUCCESS_LED, LOW);
}
}
void checkConnection() {
// Check if we haven't received a heartbeat for too long
if (millis() - lastHeartbeatReceived > HEARTBEAT_TIMEOUT) {
connectionActive = false;
digitalWrite(CONNECTION_FAIL_LED, HIGH);
digitalWrite(CONNECTION_SUCCESS_LED, LOW);
}
// Send periodic heartbeats
if (millis() - lastHeartbeatSent > HEARTBEAT_INTERVAL) {
sendHeartbeat();
lastHeartbeatSent = millis();
}
}
void setup() {
// Initialize serial for debugging
Serial.begin(115200);
// Initialize pins
pinMode(READY_LED, OUTPUT);
pinMode(LASER_ALIGNED_LED, OUTPUT);
pinMode(CONNECTION_FAIL_LED, OUTPUT);
pinMode(CONNECTION_SUCCESS_LED, OUTPUT);
pinMode(BUZZER, OUTPUT);
pinMode(LASER_SENSOR, INPUT);
// Set initial LED states
digitalWrite(READY_LED, LOW);
digitalWrite(LASER_ALIGNED_LED, LOW);
digitalWrite(CONNECTION_FAIL_LED, HIGH);
digitalWrite(CONNECTION_SUCCESS_LED, LOW);
// Initialize ESP-NOW
initESPNow();
// Attach interrupt for frequency measurement on CHANGE to catch all transitions
attachInterrupt(digitalPinToInterrupt(LASER_SENSOR), pulseCountISR, CHANGE);
Serial.println("Start Line Module Initialized");
Serial.println("Target frequency: 2000Hz +/- 1000Hz");
}
void loop() {
// Update sensor status
updateLaserStatus();
// Check for laser break to start timing
checkLaserBreak();
// Check connection status
checkConnection();
// Update ready to time status
updateReadyToTime();
// Reset timing cycle if finish line is in cooldown mode
if (timingCycleActive && remoteCooldown) {
timingCycleActive = false;
}
// Debug output every second
static unsigned long lastDebugPrint = 0;
if (millis() - lastDebugPrint > 1000) {
Serial.print("Frequency: ");
Serial.print(currentFrequency);
Serial.print(" Hz, Aligned: ");
Serial.print(laserAligned ? "YES" : "NO");
Serial.print(", Counter: ");
Serial.println(alignmentCounter);
lastDebugPrint = millis();
}
// Small delay to prevent CPU hogging
delay(1);
}
